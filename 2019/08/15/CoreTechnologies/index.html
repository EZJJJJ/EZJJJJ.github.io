<!DOCTYPE html><html lang="zh-Hans"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="CoreTechnologies"><meta name="keywords" content="Spring"><meta name="author" content="WeiZhou Jia"><meta name="copyright" content="WeiZhou Jia"><title>CoreTechnologies | 舟行北冥|Blog</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.6.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.6.1"><link rel="dns-prefetch" href="https://cdn.staticfile.org"><link rel="dns-prefetch" href="https://cdn.bootcss.com"><link rel="dns-prefetch" href="https://creativecommons.org"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css"><script src="https://cdn.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.js"></script><script src="https://cdn.jsdelivr.net/npm/blueimp-md5@2.10.0/js/md5.min.js"></script><link rel="dns-prefetch" href="https://hm.baidu.com"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?837db8124f69a3b71bbff2ed53943f88";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();</script><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  }
} </script></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Core-Technologies"><span class="toc-text">Core Technologies</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-The-IoC-Container"><span class="toc-text">1. The IoC Container</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-Introduction-to-the-Spring-IoC-Container-and-Beans"><span class="toc-text">1.1. Introduction to the Spring IoC Container and Beans</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-Container-Overview"><span class="toc-text">1.2. Container Overview</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-1-Configuration-Metadata"><span class="toc-text">1.2.1. Configuration Metadata</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-2-Instantiating-a-Container"><span class="toc-text">1.2.2. Instantiating a Container</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Composing-XML-based-Configuration-Metadata"><span class="toc-text">Composing XML-based Configuration Metadata</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#The-Groovy-Bean-Definition-DSL"><span class="toc-text">The Groovy Bean Definition DSL</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-3-Using-the-Container"><span class="toc-text">1.2.3. Using the Container</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-Bean-Overview"><span class="toc-text">1.3. Bean Overview</span></a></li></ol></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="/img/tx.jpeg"></div><div class="author-info__name text-center">WeiZhou Jia</div><div class="author-info__description text-center"></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">9</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">7</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">7</span></a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(/img/backg.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">舟行北冥|Blog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span></div><div id="post-info"><div id="post-title">CoreTechnologies</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-08-15</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/Spring/">Spring</a></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h1 id="Core-Technologies"><a href="#Core-Technologies" class="headerlink" title="Core Technologies"></a>Core Technologies</h1><p>核心技术</p>
<p>Version 5.1.9.RELEASE</p>
<ol>
<li><a href="2019/08/15/CoreTechnologies/#1-The-IoC-Container">The IoC Container</a></li>
</ol>
<a id="more"></a>

<hr>
<p><strong>This part of the reference documentation covers all the technologies that are absolutely integral to the Spring Framework.</strong></p>
<p><strong>这部分文档覆盖了Spring Framework中绝对不可或缺的所有技术。</strong></p>
<p>Foremost amongst these is the Spring Framework’s Inversion of Control (IoC) container. A thorough treatment of the Spring Framework’s IoC container is closely followed by comprehensive coverage of Spring’s Aspect-Oriented Programming (AOP) technologies. The Spring Framework has its own AOP framework, which is conceptually easy to understand and which successfully addresses the 80% sweet spot of AOP requirements in Java enterprise programming.</p>
<p>Spring Framework中最重要的部分是控制反转（IoC）容器。紧接着Spring Framework的IoC容器的全面处理，全面覆盖了Spring的（AOP）技术。Spring Framework有自己的AOP框架，它在概念上易于理解，并且成功地解决了Java企业编程中AOP要求的80％。</p>
<p>Coverage of Spring’s integration with AspectJ (currently the richest — in terms of features — and certainly most mature AOP implementation in the Java enterprise space) is also provided.</p>
<p>还提供了Spring与AspectJ的集成（目前最丰富的 - 在功能方面 - 当然也是Java企业领域中最成熟的AOP实现）。</p>
<h2 id="1-The-IoC-Container"><a href="#1-The-IoC-Container" class="headerlink" title="1. The IoC Container"></a>1. The IoC Container</h2><span id="one">

<p>IoC容器</p>
<p>This chapter covers Spring’s Inversion of Control (IoC) container.</p>
<p>本章介绍Spring的IoC容器。</p>
<h3 id="1-1-Introduction-to-the-Spring-IoC-Container-and-Beans"><a href="#1-1-Introduction-to-the-Spring-IoC-Container-and-Beans" class="headerlink" title="1.1. Introduction to the Spring IoC Container and Beans"></a>1.1. Introduction to the Spring IoC Container and Beans</h3><p>IoC容器和Bean简介</p>
<p>This chapter covers the Spring Framework implementation of the Inversion of Control (IoC) principle. IoC is also known as dependency injection (DI). It is a process whereby objects define their dependencies (that is, the other objects they work with) only through constructor arguments, arguments to a factory method, or properties that are set on the object instance after it is constructed or returned from a factory method. The container then injects those dependencies when it creates the bean. This process is fundamentally the inverse (hence the name, Inversion of Control) of the bean itself controlling the instantiation or location of its dependencies by using direct construction of classes or a mechanism such as the Service Locator pattern.</p>
<p>本章介绍了Spring Framework 如何实现IoC的原理，IoC也被称为依赖注入。这是一个过程，通过这个过程，对象只能通过构造函数参数，工厂方法的参数或在构造工厂方法返回后在对象实例上设置的属性来定义它们的依赖关系（即，它们使用的其他对象）。然后容器在创建bean时注入这些依赖项。此过程基本上是bean本身的逆（因此名称，控制反转），通过使用类的直接构造或诸如服务定位器模式的机制来控制其依赖关系的实例化或位置。</p>
<p>The <code>org.springframework.beans</code> and <code>org.springframework.context</code> packages are the basis for Spring Framework’s IoC container. The <a href="https://docs.spring.io/spring-framework/docs/5.1.9.RELEASE/javadoc-api/org/springframework/beans/factory/BeanFactory.html" target="_blank" rel="noopener"><code>BeanFactory</code></a> interface provides an advanced configuration mechanism capable of managing any type of object.<a href="https://docs.spring.io/spring-framework/docs/5.1.9.RELEASE/javadoc-api/org/springframework/context/ApplicationContext.html" target="_blank" rel="noopener"><code>ApplicationContext</code></a> is a sub-interface of <code>BeanFactory</code>. It adds:</p>
<ul>
<li>Easier integration with Spring’s AOP features</li>
<li>Message resource handling (for use in internationalization)</li>
<li>Event publication</li>
<li>Application-layer specific contexts such as the <code>WebApplicationContext</code> for use in web applications.</li>
</ul>
<p>The <code>org.springframework.beans</code> 和  <code>org.springframework.context</code> 包是Spring Framework的基础容器。 <a href="https://docs.spring.io/spring-framework/docs/5.1.9.RELEASE/javadoc-api/org/springframework/beans/factory/BeanFactory.html" target="_blank" rel="noopener"><code>BeanFactory</code></a> 接口提供一种能够管理任何类型对象的高级配置机制。<a href="https://docs.spring.io/spring-framework/docs/5.1.9.RELEASE/javadoc-api/org/springframework/context/ApplicationContext.html" target="_blank" rel="noopener"><code>ApplicationContext</code></a> 是<code>BeanFactory</code>的子接口。它补充了：</p>
<ul>
<li>与Spring的AOP功能继承更便捷。</li>
<li>消息资源处理（用于国际化）</li>
<li>活动出版</li>
<li>特定于应用程序层的上下文，例如用于Web应用程序的“WebApplicationContext”。</li>
</ul>
<p>In short, the <code>BeanFactory</code> provides the configuration framework and basic functionality, and the <code>ApplicationContext</code> adds more enterprise-specific functionality. The <code>ApplicationContext</code> is a complete superset of the <code>BeanFactory</code> and is used exclusively in this chapter in descriptions of Spring’s IoC container. For more information on using the <code>BeanFactory</code> instead of the <code>ApplicationContext,</code> see <a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#beans-beanfactory" target="_blank" rel="noopener">The <code>BeanFactory</code></a>.</p>
<p>简而言之， <code>BeanFactory</code> 提供配置框架和基本功能 ，<code>ApplicationContext</code> 加入了许多特定于企业的功能。<br><code>ApplicationContext</code>是<code>BeanFactory</code>的完整超集，在本章中仅用于描述Spring的IoC容器。有关使用<code>BeanFactory</code>而不是<code>ApplicationContext</code>的更多信息，请参阅 <a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#beans-beanfactory" target="_blank" rel="noopener"> TheBeanFactory</a>.</p>
<p>In Spring, the objects that form the backbone of your application and that are managed by the Spring IoC container are called beans. A bean is an object that is instantiated, assembled, and otherwise managed by a Spring IoC container. Otherwise, a bean is simply one of many objects in your application. Beans, and the dependencies among them, are reflected in the configuration metadata used by a container.</p>
<p>在Spring中，构成应用程序主干并由Spring IoC容器管理的对象称为bean。bean是一个由Spring IoC容器实例化，组装和管理的对象。除此之外，bean只是应用程序中众多对象中的一个。Bean及其之间的依赖关系反映在容器使用的配置元数据中。</p>
<h3 id="1-2-Container-Overview"><a href="#1-2-Container-Overview" class="headerlink" title="1.2. Container Overview"></a>1.2. Container Overview</h3><p>容器概览</p>
<p>The <code>org.springframework.context.ApplicationContext</code> interface represents the Spring IoC container and is responsible for instantiating, configuring, and assembling the beans. The container gets its instructions on what objects to instantiate, configure, and assemble by reading configuration metadata. The configuration metadata is represented in XML, Java annotations, or Java code. It lets you express the objects that compose your application and the rich interdependencies between those objects.</p>
<p>The <code>org.springframework.context.ApplicationContext</code> 接口表示Spring IoC容器，负责实例化，配置和组装bean。容器通过读取配置元数据获取有关要实例化，配置和组装的对象的指令。配置数据以XML，Java注释或Java代码表示。</p>
<p>Several implementations of the <code>ApplicationContext</code> interface are supplied with Spring. In stand-alone applications, it is common to create an instance of <a href="https://docs.spring.io/spring-framework/docs/5.1.9.RELEASE/javadoc-api/org/springframework/context/support/ClassPathXmlApplicationContext.html" target="_blank" rel="noopener"><code>ClassPathXmlApplicationContext</code></a> or <a href="https://docs.spring.io/spring-framework/docs/5.1.9.RELEASE/javadoc-api/org/springframework/context/support/FileSystemXmlApplicationContext.html" target="_blank" rel="noopener"><code>FileSystemXmlApplicationContext</code></a>. While XML has been the traditional format for defining configuration metadata, you can instruct the container to use Java annotations or code as the metadata format by providing a small amount of XML configuration to declaratively enable support for these additional metadata formats.</p>
<p>Spring提供了几个<code>ApplicationContext</code>接口的实现。在独立的应用程序中，通常会创建 <a href="https://docs.spring.io/spring-framework/docs/5.1.9.RELEASE/javadoc-api/org/springframework/context/support/ClassPathXmlApplicationContext.html" target="_blank" rel="noopener"><code>ClassPathXmlApplicationContext</code></a> or <a href="https://docs.spring.io/spring-framework/docs/5.1.9.RELEASE/javadoc-api/org/springframework/context/support/FileSystemXmlApplicationContext.html" target="_blank" rel="noopener"><code>FileSystemXmlApplicationContext</code></a> 的实例. 虽然XML是定义配置元数据的传统格式，但您可以通过提供少量XML配置来声明容器使用Java注释或代码作为元数据格式，以声明方式启用对这些其他元数据格式的支持。</p>
<p>In most application scenarios, explicit user code is not required to instantiate one or more instances of a Spring IoC container. For example, in a web application scenario, a simple eight (or so) lines of boilerplate web descriptor XML in the <code>web.xml</code> file of the application typically suffices (see <a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#context-create" target="_blank" rel="noopener">Convenient ApplicationContext Instantiation for Web Applications</a>). If you use the <a href="https://spring.io/tools/sts" target="_blank" rel="noopener">Spring Tool Suite</a> (an Eclipse-powered development environment), you can easily create this boilerplate configuration with a few mouse clicks or keystrokes.</p>
<p>在大多数应用场景下，实例化Spring IoC容器的一个或多个实例不需要显示用户代码。例如web应用场景中，应用程序的<code>web.xml</code>文件中的简单的八行（左右）样板Web描述符XML通常就足够了。如果您使用 <a href="https://spring.io/tools/sts" target="_blank" rel="noopener">Spring Tool Suite</a>（基于Eclipse的开发环境），只需点击几下鼠标或按键即可轻松创建此样板配置。</p>
<p>The following diagram shows a high-level view of how Spring works. Your application classes are combined with configuration metadata so that, after the <code>ApplicationContext</code> is created and initialized, you have a fully configured and executable system or application.</p>
<p>下图显示了Spring如何工作的高级视图。 您的应用程序类与配置元数据相结合，以便在创建和初始化<code>ApplicationContext</code>之后，您拥有一个完全配置且可执行的系统或应用程序。</p>
<p><img src="https://docs.spring.io/spring/docs/current/spring-framework-reference/images/container-magic.png" alt="container magic"></p>
<p>Figure 1. The Spring IoC container</p>
<h4 id="1-2-1-Configuration-Metadata"><a href="#1-2-1-Configuration-Metadata" class="headerlink" title="1.2.1. Configuration Metadata"></a>1.2.1. Configuration Metadata</h4><p>配置元数据</p>
<p>As the preceding diagram shows, the Spring IoC container consumes a form of configuration metadata. This configuration metadata represents how you, as an application developer, tell the Spring container to instantiate, configure, and assemble the objects in your application.</p>
<p>如上图所示，Spring IoC容器使用一种配置元数据。此配置元数据表示您作为应用程序开发人员如何告诉Spring容器在应用程序中实例化，配置和组装对象。</p>
<p>Configuration metadata is traditionally supplied in a simple and intuitive XML format, which is what most of this chapter uses to convey key concepts and features of the Spring IoC container.</p>
<p>传统上，配置元数据以简单直观的XML格式提供，本章的大部分内容用于传达Spring IoC容器的关键概念和功能。</p>
<blockquote>
<p>XML-based metadata is not the only allowed form of configuration metadata. The Spring IoC container itself is totally decoupled from the format in which this configuration metadata is actually written. These days, many developers choose <a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#beans-java" target="_blank" rel="noopener">Java-based configuration</a> for their Spring applications.</p>
<p>基于XML的元数据不是唯一允许的配置元数据形式。 Spring IoC容器本身完全与实际编写此配置元数据的格式分离。 目前，许多开发人员为其Spring应用程序选择 <a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#beans-java" target="_blank" rel="noopener">Java-based configuration</a> 。</p>
</blockquote>
<p>For information about using other forms of metadata with the Spring container, see:</p>
<ul>
<li><a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#beans-annotation-config" target="_blank" rel="noopener">Annotation-based configuration</a>: Spring 2.5 introduced support for annotation-based configuration metadata.</li>
<li><a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#beans-java" target="_blank" rel="noopener">Java-based configuration</a>: Starting with Spring 3.0, many features provided by the Spring JavaConfig project became part of the core Spring Framework. Thus, you can define beans external to your application classes by using Java rather than XML files. To use these new features, see the <a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/context/annotation/Configuration.html" target="_blank" rel="noopener"><code>@Configuration</code></a>, <a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/context/annotation/Bean.html" target="_blank" rel="noopener"><code>@Bean</code></a>, <a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/context/annotation/Import.html" target="_blank" rel="noopener"><code>@Import</code></a>, and <a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/context/annotation/DependsOn.html" target="_blank" rel="noopener"><code>@DependsOn</code></a> annotations.</li>
</ul>
<p>有关在Spring容器中使用其他形式的元数据的信息，参阅：</p>
<ul>
<li><a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#beans-annotation-config" target="_blank" rel="noopener">Annotation-based configuration</a>: Spring 2.5引入了对基于注释的配置元数据的支持。</li>
<li><a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#beans-java" target="_blank" rel="noopener">Java-based configuration</a>: 从Spring 3.0开始，Spring JavaConfig项目提供了许多功能 成为核心Spring框架的一部分。 因此，您可以使用Java而不是XML文件在应用程序类外部定义bean。 要使用这些新功能请参阅<a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/context/annotation/Configuration.html" target="_blank" rel="noopener"><code>@Configuration</code></a>, <a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/context/annotation/Bean.html" target="_blank" rel="noopener"><code>@Bean</code></a>, <a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/context/annotation/Import.html" target="_blank" rel="noopener"><code>@Import</code></a>, 和 <a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/context/annotation/DependsOn.html" target="_blank" rel="noopener"><code>@DependsOn</code></a> 注释.</li>
</ul>
<p>Spring configuration consists of at least one and typically more than one bean definition that the container must manage. XML-based configuration metadata configures these beans as <code>&lt;bean/&gt;</code> elements inside a top-level <code>&lt;beans/&gt;</code> element. Java configuration typically uses <code>@Bean</code>-annotated methods within a <code>@Configuration</code> class.</p>
<p>Spring配置容器必须管理的至少一个且通常不止一个bean。 基于XML的配置的元数据将这些bean配置为最外层<code>&lt;beans /&gt;</code>元素中的<code>&lt;bean /&gt;</code>元素。 Java配置通常在<code>@Configuration</code>注释类中使用<code>@ Bean</code>注释方法。</p>
<p>These bean definitions correspond to the actual objects that make up your application. Typically, you define service layer objects, data access objects (DAOs), presentation objects such as Struts <code>Action</code> instances, infrastructure objects such as Hibernate <code>SessionFactories</code>, JMS <code>Queues</code>, and so forth. Typically, one does not configure fine-grained domain objects in the container, because it is usually the responsibility of DAOs and business logic to create and load domain objects. However, you can use Spring’s integration with AspectJ to configure objects that have been created outside the control of an IoC container. See <a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#aop-atconfigurable" target="_blank" rel="noopener">Using AspectJ to dependency-inject domain objects with Spring</a>.</p>
<p>这些bean定义对应于构成应用程序的实际对象。 通常，您定义服务层对象，数据访问对象（DAO），表示对象（如Struts<code>Action</code>实例），基础结构对象（如Hibernate“SessionFactories”，JMS“Queues”等）等。 通常，不会在容器中配置细粒度域对象，因为DAO和业务逻辑通常负责创建和加载域对象。 但是，您可以使用Spring与AspectJ的集成来配置在IoC容器控制之外创建的对象。</p>
<p>The following example shows the basic structure of XML-based configuration metadata:</p>
<p>以下示例显示了基于XML的配置元数据的基本结构：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">        https://www.springframework.org/schema/beans/spring-beans.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"..."</span> <span class="attr">class</span>=<span class="string">"..."</span>&gt;</span>   </span><br><span class="line">        <span class="comment">&lt;!-- collaborators and configuration for this bean go here --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"..."</span> <span class="attr">class</span>=<span class="string">"..."</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- collaborators and configuration for this bean go here --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- more bean definitions go here --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>The <code>id</code> attribute is a string that identifies the individual bean definition.</p>
</li>
<li><p><code>id</code>属性是一个标识单个bean定义的字符串。可以理解为类名</p>
</li>
<li><p>The <code>class</code> attribute defines the type of the bean and uses the fully qualified classname.</p>
</li>
<li><p><code>class</code>属性定义bean的类型并使用完全限定的类名。可以理解为类路径</p>
</li>
</ul>
<p>The value of the <code>id</code> attribute refers to collaborating objects. The XML for referring to collaborating objects is not shown in this example. See <a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#beans-dependencies" target="_blank" rel="noopener">Dependencies</a> for more information.</p>
<p><code>id</code>属性的值指的是协作对象。 在此示例中未显示用于引用协作对象的XML。有关详细信息，请参阅 <a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#beans-dependencies" target="_blank" rel="noopener">Dependencies</a> </p>
<h4 id="1-2-2-Instantiating-a-Container"><a href="#1-2-2-Instantiating-a-Container" class="headerlink" title="1.2.2. Instantiating a Container"></a>1.2.2. Instantiating a Container</h4><p>实例化容器</p>
<p>The location path or paths supplied to an <code>ApplicationContext</code> constructor are resource strings that let the container load configuration metadata from a variety of external resources, such as the local file system, the Java <code>CLASSPATH</code>, and so on.</p>
<p>为<code>ApplicationContext</code>构造函数提供位置路径的是一串资源字符串，它允许容器从各种外部资源（例如本地文件系统，Java<code>CLASSPATH</code>等）加载配置元数据。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"services.xml"</span>, <span class="string">"daos.xml"</span>);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>After you learn about Spring’s IoC container, you may want to know more about Spring’s <code>Resource</code> abstraction (as described in <a href="https://docs.spring.io/spring/docs/5.1.9.RELEASE/spring-framework-reference/core.html#resources" target="_blank" rel="noopener">Resources</a>), which provides a convenient mechanism for reading an InputStream from locations defined in a URI syntax. In particular, <code>Resource</code> paths are used to construct applications contexts, as described in <a href="https://docs.spring.io/spring/docs/5.1.9.RELEASE/spring-framework-reference/core.html#resources-app-ctx" target="_blank" rel="noopener">Application Contexts and Resource Paths</a>.</p>
<p>在了解了Spring的IoC容器之后，您可能想要了解有关Spring的“Resource”抽象的更多信息（如 <a href="https://docs.spring.io/spring/docs/5.1.9.RELEASE/spring-framework-reference/core.html#resources" target="_blank" rel="noopener">Resources</a>中所述），它提供了一种从URI语法中定义的位置读取InputStream的便捷机制。 特别是， <code>Resource</code> 路径用于构建应用程序上下文，如 <a href="https://docs.spring.io/spring/docs/5.1.9.RELEASE/spring-framework-reference/core.html#resources-app-ctx" target="_blank" rel="noopener">Application Contexts and Resource Paths</a>中所述。</p>
</blockquote>
<p>The following example shows the service layer objects <code>(services.xml)</code> configuration file:</p>
<p>以下示例显示了服务层对象<code>（services.xml）</code>配置文件：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">        https://www.springframework.org/schema/beans/spring-beans.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- services --&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"petStore"</span> <span class="attr">class</span>=<span class="string">"org.springframework.samples.jpetstore.services.PetStoreServiceImpl"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"accountDao"</span> <span class="attr">ref</span>=<span class="string">"accountDao"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"itemDao"</span> <span class="attr">ref</span>=<span class="string">"itemDao"</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- additional collaborators and configuration for this bean go here --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- more bean definitions for services go here --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>The following example shows the data access objects <code>daos.xml</code> file:</p>
<p>以下示例显示了数据访问层对象<code>（daos.xml）</code>配置文件：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">        https://www.springframework.org/schema/beans/spring-beans.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"accountDao"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">class</span>=<span class="string">"org.springframework.samples.jpetstore.dao.jpa.JpaAccountDao"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- additional collaborators and configuration for this bean go here --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"itemDao"</span> <span class="attr">class</span>=<span class="string">"org.springframework.samples.jpetstore.dao.jpa.JpaItemDao"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- additional collaborators and configuration for this bean go here --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- more bean definitions for data access objects go here --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>In the preceding example, the service layer consists of the <code>PetStoreServiceImpl</code> class and two data access objects of the types <code>JpaAccountDao</code> and <code>JpaItemDao</code> (based on the JPA Object-Relational Mapping standard). The <code>property name</code> element refers to the name of the JavaBean property, and the <code>ref</code> element refers to the name of another bean definition. This linkage between <code>id</code> and <code>ref</code> elements expresses the dependency between collaborating objects. For details of configuring an object’s dependencies, see <a href="https://docs.spring.io/spring/docs/5.1.9.RELEASE/spring-framework-reference/core.html#beans-dependencies" target="_blank" rel="noopener">Dependencies</a>.</p>
<p>在前面的示例中，服务层包含<code>PetStoreServiceImpl</code>类和两个类型为<code>JpaAccountDao</code>和<code>JpaItemDao</code>的数据访问对象（基于JPA对象关系映射标准）。<code>property name</code>元素引用JavaBean属性的名称，<code>ref</code>元素引用另一个bean定义的名称。（这里的name和ref虽然是同名的，但是name是指petStore类中的参数，petStore类中有一个AccountDao类型名叫accountDao的对象，而ref是当前xml文件中叫做accountDao的这个bean，把它当作参数传进petStore中。）<code>id</code>和<code>ref</code>元素之间的这种联系表达了协作对象之间的依赖关系。有关配置对象的依赖项的详细信息，参阅 <a href="https://docs.spring.io/spring/docs/5.1.9.RELEASE/spring-framework-reference/core.html#beans-dependencies" target="_blank" rel="noopener">Dependencies</a>.</p>
<h5 id="Composing-XML-based-Configuration-Metadata"><a href="#Composing-XML-based-Configuration-Metadata" class="headerlink" title="Composing XML-based Configuration Metadata"></a>Composing XML-based Configuration Metadata</h5><p>编写基于XML的配置元数据</p>
<p>It can be useful to have bean definitions span multiple XML files. Often, each individual XML configuration file represents a logical layer or module in your architecture.</p>
<p>让bean定义跨越多个XML文件会很有用。 通常，每个单独的XML配置文件都代表架构中的逻辑层或模块。</p>
<p>You can use the application context constructor to load bean definitions from all these XML fragments. This constructor takes multiple <code>Resource</code> locations, as was shown in the <a href="https://docs.spring.io/spring/docs/5.1.9.RELEASE/spring-framework-reference/core.html#beans-factory-instantiation" target="_blank" rel="noopener">previous section</a>. Alternatively, use one or more occurrences of the <code>&lt;import/&gt;</code> element to load bean definitions from another file or files. The following example shows how to do so:</p>
<p>你可以用application context constructor从所有的XML中加载Bean定义。这个构造函数需要多个<code>Resource</code>位置，如 <a href="https://docs.spring.io/spring/docs/5.1.9.RELEASE/spring-framework-reference/core.html#beans-factory-instantiation" target="_blank" rel="noopener">previous section</a>所示。或者，使用一个或多个<code>&lt;import /&gt;</code>元素来从另一个或多个文件加载bean定义。以下示例显示了如何执行此操作：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">import</span> <span class="attr">resource</span>=<span class="string">"services.xml"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">import</span> <span class="attr">resource</span>=<span class="string">"resources/messageSource.xml"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">import</span> <span class="attr">resource</span>=<span class="string">"/resources/themeSource.xml"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"bean1"</span> <span class="attr">class</span>=<span class="string">"..."</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"bean2"</span> <span class="attr">class</span>=<span class="string">"..."</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>In the preceding example, external bean definitions are loaded from three files: <code>services.xml</code>, <code>messageSource.xml</code>, and <code>themeSource.xml</code>. All location paths are relative to the definition file doing the importing, so <code>services.xml</code> must be in the same directory or classpath location as the file doing the importing, while <code>messageSource.xml</code> and <code>themeSource.xml</code> must be in a <code>resources</code> location below the location of the importing file. As you can see, a leading slash is ignored. However, given that these paths are relative, it is better form not to use the slash at all. The contents of the files being imported, including the top level <code>&lt;beans/&gt;</code> element, must be valid XML bean definitions, according to the Spring Schema.</p>
<p>在前面的示例中，外部bean定义从三个文件加载： <code>services.xml</code>, <code>messageSource.xml</code>, and <code>themeSource.xml</code>。所有位置路径都相对于执行导入的定义文件，因此<code>services.xml</code>必须与执行导入的文件位于相同的目录或类路径位置，而<code>messageSource.xml</code>和<code>themeSource.xml</code>必须位于导入文件位置下方的<code>resources</code>位置。如您所见，忽略前斜杠。但是，鉴于这些路径是相对的，最好不要使用斜杠。根据Spring Schema，导入文件的内容（包括<code>&lt;beans /&gt;</code>元素）必须是有效的XML bean定义。</p>
<blockquote>
<p>It is possible, but not recommended, to reference files in parent directories using a relative “../“ path. Doing so creates a dependency on a file that is outside the current application. In particular, this reference is not recommended for <code>classpath:</code> URLs (for example, <code>classpath:../services.xml</code>), where the runtime resolution process chooses the “nearest” classpath root and then looks into its parent directory. Classpath configuration changes may lead to the choice of a different, incorrect directory.</p>
<p>You can always use fully qualified resource locations instead of relative paths: for example, <code>file:C:/config/services.xml</code> or <code>classpath:/config/services.xml</code>. However, be aware that you are coupling your application’s configuration to specific absolute locations. It is generally preferable to keep an indirection for such absolute locations — for example, through “${…}” placeholders that are resolved against JVM system properties at runtime.</p>
</blockquote>
<blockquote>
<p>可以（但不建议）使用相对“../”路径引用父目录中的文件。这样做会对当前应用程序之外的文件创建依赖关系。特别是，不建议将此引用用于<code>classpath：</code>URL（例如，<code>classpath：../ services.xml</code>），其中运行时解析过程选择“最近的”类路径根，然后查看其父目录。类路径配置更改可能导致选择不同的不正确的目录。</p>
<p>您始终可以使用绝对路径的资源位置而不是相对路径。例如<code>file:C:/config/services.xml</code> or <code>classpath:/config/services.xml</code>. 但是，请注意您将应用程序的配置与特定的绝对位置耦合。通常最好为这些绝对位置保持连接 - 例如，通过在运行时针对JVM系统属性解析的“$ {…}”占位符。</p>
</blockquote>
<p>The namespace itself provices the import directive feature. Further configuration features beyond plain bean definitions are available in a selection of XML namespaces provided by Spring — for example, the <code>context</code> and <code>util</code> namespaces.</p>
<p>命名空间本身提供了导入指令功能。 除了普通bean定义之外的其他配置功能在Spring提供的一系列XML命名空间中可用 - 例如，<code>context</code>和<code>util</code>命名空间。</p>
<h5 id="The-Groovy-Bean-Definition-DSL"><a href="#The-Groovy-Bean-Definition-DSL" class="headerlink" title="The Groovy Bean Definition DSL"></a>The Groovy Bean Definition DSL</h5><p>Groovy Bean定义DSL</p>
<p>As a further example for externalized configuration metadata, bean definitions can also be expressed in Spring’s Groovy Bean Definition DSL, as known from the Grails framework. Typically, such configuration live in a “.groovy” file with the structure shown in the following example:</p>
<p>作为外化配置元数据的另一个示例，bean定义也可以在Spring的Groovy Bean定义DSL中表示，如Grails框架中所知。 通常，此类配置位于“.groovy”文件中，其结构如下例所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">beans &#123;</span><br><span class="line">    dataSource(BasicDataSource) &#123;</span><br><span class="line">        driverClassName = <span class="string">"org.hsqldb.jdbcDriver"</span></span><br><span class="line">        url = <span class="string">"jdbc:hsqldb:mem:grailsDB"</span></span><br><span class="line">        username = <span class="string">"sa"</span></span><br><span class="line">        password = <span class="string">""</span></span><br><span class="line">        settings = [mynew:<span class="string">"setting"</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    sessionFactory(SessionFactory) &#123;</span><br><span class="line">        dataSource = dataSource</span><br><span class="line">    &#125;</span><br><span class="line">    myService(MyService) &#123;</span><br><span class="line">        nestedBean = &#123; AnotherBean bean -&gt;</span><br><span class="line">            dataSource = dataSource</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>This configuration style is largely equivalent to XML bean definitions and even supports Spring’s XML configuration namespaces. It also allows for importing XML bean definition files through an <code>importBeans</code> directive.</p>
<p>此配置样式在很大程度上等同于XML bean定义，甚至支持Spring的XML配置命名空间。 它还允许通过<code>importBeans</code>指令导入XML bean定义文件。</p>
<h4 id="1-2-3-Using-the-Container"><a href="#1-2-3-Using-the-Container" class="headerlink" title="1.2.3. Using the Container"></a>1.2.3. Using the Container</h4><p>适用容器</p>
<p>The <code>ApplicationContext</code> is the interface for an advanced factory capable of maintaining a registry of different beans and their dependencies. By using the method <code>T getBean(String name, Class&lt;T&gt; requiredType)</code>, you can retrieve instances of your beans.</p>
<p><code>ApplicationContext</code>是高级工厂的接口，能够维护不同bean及其依赖项的注册表。 通过使用方法<code>T getBean（String name，Class &lt;T&gt; requiredType）</code>，您可以检索bean的实例。</p>
<p>The <code>ApplicationContext</code> lets you read bean definitions and access them, as the following example shows:</p>
<p><code>ApplicationContext</code>允许您读取bean定义并访问它们，如以下示例所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// create and configure beans</span></span><br><span class="line">ApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"services.xml"</span>, <span class="string">"daos.xml"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// retrieve configured instance</span></span><br><span class="line">PetStoreService service = context.getBean(<span class="string">"petStore"</span>, PetStoreService.class);</span><br><span class="line"></span><br><span class="line"><span class="comment">// use configured instance</span></span><br><span class="line">List&lt;String&gt; userList = service.getUsernameList();</span><br></pre></td></tr></table></figure>

<p>With Groovy configuration, bootstrapping looks very similar. It has a different context implementation class which is Groovy-aware (but also understands XML bean definitions). The following example shows Groovy configuration:</p>
<p>使用Groovy配置，bootstrapping看起来非常相似。 它有一个不同的上下文实现类，它是Groovy-aware（但也理解XML bean定义）。 以下示例显示了Groovy配置：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ApplicationContext context = <span class="keyword">new</span> GenericGroovyApplicationContext(<span class="string">"services.groovy"</span>, <span class="string">"daos.groovy"</span>);</span><br></pre></td></tr></table></figure>

<p>The most flexible variant is <code>GenericApplicationContext</code> in combination with reader delegates — for example, with <code>XmlBeanDefinitionReader</code> for XML files, as the following example shows:</p>
<p>最灵活的变体是<code>GenericApplicationContext</code>与读者委托相结合 - 例如，对于XML文件使用<code>XmlBeanDefinitionReader</code>，如下例所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GenericApplicationContext context = <span class="keyword">new</span> GenericApplicationContext();</span><br><span class="line"><span class="keyword">new</span> XmlBeanDefinitionReader(context).loadBeanDefinitions(<span class="string">"services.xml"</span>, <span class="string">"daos.xml"</span>);</span><br><span class="line">context.refresh();</span><br></pre></td></tr></table></figure>

<p>You can also use the <code>GroovyBeanDefinitionReader</code> for Groovy files, as the following example shows:</p>
<p>您还可以对Groovy文件使用<code>GroovyBeanDefinitionReader</code>，如以下示例所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GenericApplicationContext context = <span class="keyword">new</span> GenericApplicationContext();</span><br><span class="line"><span class="keyword">new</span> GroovyBeanDefinitionReader(context).loadBeanDefinitions(<span class="string">"services.groovy"</span>, <span class="string">"daos.groovy"</span>);</span><br><span class="line">context.refresh();</span><br></pre></td></tr></table></figure>

<p>You can mix and match such reader delegates on the same <code>ApplicationContext</code>, reading bean definitions from diverse configuration sources.</p>
<p>您可以在同一个ApplicationContext上混合和匹配此类读者委托，从不同的配置源中读取bean定义。</p>
<p>You can then use <code>getBean</code> to retrieve instances of your beans. The <code>ApplicationContext</code> interface has a few other methods for retrieving beans, but, ideally, your application code should never use them. Indeed, your application code should have no calls to the <code>getBean()</code> method at all and thus have no dependency on Spring APIs at all. For example, Spring’s integration with web frameworks provides dependency injection for various web framework components such as controllers and JSF-managed beans, letting you declare a dependency on a specific bean through metadata (such as an autowiring annotation).</p>
<p>然后，您可以使用<code>getBean</code>来检索bean的实例。 <code>ApplicationContext</code>接口有一些其他的方法来检索bean，但理想情况下，你的应用程序代码永远不应该使用它们。 实际上，您的应用程序代码根本不应该调用<code>getBean（）</code>方法，因此根本不依赖于Spring API。 例如，Spring与Web框架的集成为各种Web框架组件（如控制器和JSF托管bean）提供依赖注入，允许您通过元数据（例如自动装配注释）声明对特定bean的依赖性。</p>
<h3 id="1-3-Bean-Overview"><a href="#1-3-Bean-Overview" class="headerlink" title="1.3. Bean Overview"></a>1.3. Bean Overview</h3><p>Bean总览</p>
</span></div></article><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Spring/">Spring</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2019/08/29/Java设计模式/"><i class="fa fa-chevron-left">  </i><span>Java设计模式</span></a></div><div class="next-post pull-right"><a href="/2019/08/14/Spring Framework Overview/"><span>Spring Framework Overview</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="gitalk-container"></div><script>var gitalk = new Gitalk({
  clientID: 'fcd8fb3eb22ed54c8e09',
  clientSecret: 'eac7e3ae1a290e0334e6d466cd157c8f194ce624',
  repo: 'EZJJJJ.github.io',
  owner: 'EZJJJJ',
  admin: 'EZJJJJ',
  id: md5(decodeURI(location.pathname)),
  language: 'zh-CN'
})
gitalk.render('gitalk-container')</script></div></div><footer class="footer-bg" style="background-image: url(/img/backg.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2013 - 2019 By WeiZhou Jia</div><div class="framework-info"><span>驱动 - </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file-o"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.6.1"></script><script src="/js/fancybox.js?version=1.6.1"></script><script src="/js/sidebar.js?version=1.6.1"></script><script src="/js/copy.js?version=1.6.1"></script><script src="/js/fireworks.js?version=1.6.1"></script><script src="/js/transition.js?version=1.6.1"></script><script src="/js/scroll.js?version=1.6.1"></script><script src="/js/head.js?version=1.6.1"></script><script>if(/Android|webOS|iPhone|iPod|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
}</script></body></html>